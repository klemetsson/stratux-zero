//=========================================================
// src/stratux-mcu_main.c: generated by Hardware Configurator
//
// This file will be updated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!!
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------

#include <SI_EFM8BB1_Register_Enums.h>                  // SFR declarations
#include <rtx51tny.h>
#include "InitDevice.h"
#include "DeviceConfig.h"

// $[Generated Includes]
// [Generated Includes]$

//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------

void SiLabs_Startup(void) {
  // $[SiLabs Startup]
  // [SiLabs Startup]$
}

//-----------------------------------------------------------------------------
// Main task
// ----------------------------------------------------------------------------

uint8_t data stratux_state = STATE_BOOT;
uint8_t data watchdog_mask = WATCHDOG_MASK;

void task_main(void) _task_ TASK_ID_MAIN {
  uint8_t i;

  stratux_state = STATE_BOOT;

  // Call hardware initialization routine
  enter_DefaultMode_from_RESET();

  // Wake the fuel gauge
  O_GPOUT = false;
  os_wait2(K_TMO, 5);
  O_GPOUT = true;

  // Fix the SMBus slave state in case of improper reset
  while (!IO_SDA) {
      O_SCL = false;
      for (i = 0; i < 255; i++);
      O_SCL = true;
      while (!O_SCL);
      for (i = 0; i < 50; i++);
  }

  // Enable SMBus
  enter_ReadyMode_from_DefaultMode();

  // Start the other tasks
  os_create_task(TASK_ID_INDICATORS);
  os_create_task(TASK_ID_SENSORS);

  while (true) {
	  switch (stratux_state) {
      case STATE_BOOT:
        if (bat_charge == BAT_CHARGE_EMPTY) {
          stratux_state = STATE_POWEROFF;
        }
        else if (!I_SHDN) {
            stratux_state = STATE_SHUTDOWN;
        }
        else if (bat_charge != BAT_CHARGE_UNKNOWN) {
          stratux_state = STATE_START;
        }
        break;

      case STATE_START:
        O_EN = true;
        O_RST = true;
        O_PISHDN = true;
        os_wait2(K_TMO, 20);
        if (I_SHDN) {
          O_RST = false;
          stratux_state = STATE_START_GRACE;
          main_countdown = 8 * 2;
        }
        else {
          stratux_state = STATE_SHUTDOWN;
        }
        break;

      case STATE_START_GRACE:
        if (!main_countdown) {
            stratux_state = STATE_STARTING;
            main_countdown = 9 * 2;
        }
        break;

      case STATE_STARTING:
        if (stratux_status == STRATUX_RUNNING) {
          stratux_state = STATE_RUNNING;
        }
        else if (stratux_status == STRATUX_READY) {
          stratux_state = STATE_READY;
        }
        // 8 + 9 seconds has passed
        else if (!main_countdown) {
          stratux_state = STATE_START_TIMEOUT;
        }
        break;

      case STATE_START_TIMEOUT:
        if (I_SHDN) {
          stratux_state = STATE_START;
        }
        else {
          stratux_state = STATE_STOP;
        }
        break;

      case STATE_RUNNING:
      case STATE_READY:
        if (bat_charge == BAT_CHARGE_EMPTY || !I_SHDN) {
          stratux_state = STATE_STOP;
        }
        else if (stratux_status == STRATUX_RUNNING) {
          stratux_state = STATE_RUNNING;
        }
        else if (stratux_status == STRATUX_READY) {
          stratux_state = STATE_READY;
        }
        else if (stratux_status == STRATUX_TIMEOUT) {
          stratux_state = STATE_STOP;
        }
        break;

      case STATE_STOP:
        O_PISHDN = false;
        stratux_state = STATE_STOPPING;
        main_countdown = 9 * 2;
        break;

      case STATE_STOPPING:
        // 9 seconds has passed
        if (!main_countdown) {
            stratux_state = STATE_SHUTDOWN;
        }
        break;

      case STATE_SHUTDOWN:
        O_RST = true;
        O_PISHDN = true;
        if (bat_charge == BAT_CHARGE_EMPTY) {
          stratux_state = STATE_POWEROFF;
        }
        else if (I_SHDN) {
          stratux_state = STATE_BOOT;
        }
        else O_EN = false;
        break;

      case STATE_POWEROFF:
        O_RST = true;
        O_PISHDN = true;
        if (bat_charge != BAT_CHARGE_EMPTY) {
          stratux_state = STATE_SHUTDOWN;
        }
        else O_EN = false;
        break;

      default:
        stratux_state = STATE_BOOT;
	  }

	  // Reset watchdog if all flags are cleared
	  if (!watchdog_mask) {
      WDTCN = 0xA5;
      watchdog_mask = WATCHDOG_MASK;
    }
	  // Switch to next task
	  os_switch_task();
  }                             

}

//-----------------------------------------------------------------------------
// Task for managing all the indicators
// ----------------------------------------------------------------------------

uint8_t data stratux_status = STRATUX_UNKNOWN;

void task_indicator(void) _task_ TASK_ID_INDICATORS {
	uint8_t offset, local_interval;
	bit is_on, pi_ready;

	is_on = false;
	pi_ready = I_PIRDY;
	stratux_status = STRATUX_UNKNOWN;
	status_countup = 0;

	while (true) {

		// Handle LEDs and the buzzer
		if (stratux_state && stratux_state < STATE_SHUTDOWN) {
			// Sync blinking with the power on event
			if (!is_on) {
				is_on = true;
				offset = interval;
			}
			local_interval = interval - offset;

			// Power LED
			if (!I_SHDN) {
			    LED_POWER = true;
			}
			else if (bat_charge == BAT_CHARGE_CRITICAL) {
				// 500 ms on, 500 ms off
				LED_POWER = (bit)(local_interval & 0x10);
			}
			else if (bat_charge == BAT_CHARGE_WARNING || bat_charge == BAT_CHARGE_ERROR) {
				// 3500 ms on, 500 ms off
				LED_POWER = (local_interval & 0x70) == 0x70;
			}
			else {
				LED_POWER = false;
			}

			// CO alert LED
			if (co_level == CO_LEVEL_LETHAL) {
				// 500 ms on, 500 ms off
				LED_ALARM = (bit)(local_interval & 0x10);
			}
			else if (co_level == CO_LEVEL_CRITICAL) {
				// 500 ms on, 3500 ms off
				LED_ALARM = (local_interval & 0x70) != 0x00;
			}
			else if (co_level == CO_LEVEL_WARNING) {
				// 500 ms on, 7500 ms off
				LED_ALARM = (local_interval & 0xf0) != 0x00;
			}
			else {
				LED_ALARM = true;
			}

			// Stratux ready LED
			if (stratux_state == STATE_READY)
				LED_READY = false;
			else if (stratux_state == STATE_RUNNING)
				// 1500 ms on, 500 ms off
				LED_READY = (local_interval & 0x30) == 0x30;
			else
				// 500 ms on, 500 ms off
				LED_READY = (bit)(local_interval & 0x10);

		}
		else {
			is_on = false;
			LED_POWER = true;
			LED_READY = true;
			LED_ALARM = true;
			stop_buzzer();
		}

		// Disable charging if temperature out of range
		if (bat_temp_ok || !has_ext_pwr()) {
			charge_enable();
		}
		else {
			charge_disable();
		}

		// Detect Stratux heartbeat
		if (stratux_state < STATE_STARTING || stratux_state > STATE_STOPPING) {
		    pi_ready = I_PIRDY;
		    status_countup = 0;
		    stratux_status = STRATUX_UNKNOWN;
		}
		else if (pi_ready != I_PIRDY) {
			pi_ready = I_PIRDY;
			// Falling edge
			if (!pi_ready) {
				// Pulse > 350 ms, 200 ms nominal is Stratux running and ready
				if (status_countup > 11) {
					stratux_status = STRATUX_READY;
				}
				// Pulse < 350 ms, 500 ms nominal is Stratux running but waiting for GNSS
				else if (status_countup > 4) {
					stratux_status = STRATUX_RUNNING;
				}
			}
			status_countup = 0;
		}
		// Timeout 2 s
		else if (status_countup > 64) {
			stratux_status = STRATUX_TIMEOUT;
		}

		// Switch to next task
		watchdog_mask &= ~WATCHDOG_MASK_INDICATORS;
		os_switch_task();
	}
}

//-----------------------------------------------------------------------------
// Task for reading sensor values
// ----------------------------------------------------------------------------

bit bat_temp_ok = true;
uint8_t data bat_charge = BAT_CHARGE_UNKNOWN;
uint8_t data co_level = CO_LEVEL_UNKNOWN;

void task_sensors(void) _task_ TASK_ID_SENSORS {
	uint16_t sample;
	uint8_t loop = 0;

	bit temp = false;

	bat_charge = BAT_CHARGE_OK;
	co_level = CO_LEVEL_OK;
	bat_temp_ok = true;

	while (true) {
		// Read battery temperature and see if it is safe to charge
		if (!(loop & 31)) {
			ADC0MX = 0x05; // P0.5
			ADC0 = 0x00;
			ADC0CN0_ADBUSY = true;
			os_wait1(RDY_EVENT);
			sample = ADC0;
			bat_temp_ok = bat_temp_ok
					? sample >= BAT_TEMP_HIGH_ON && sample <= BAT_TEMP_LOW_ON
					: sample <= BAT_TEMP_HIGH_OFF && sample <= BAT_TEMP_LOW_OFF;
		}

		// Read CO level
    if (!(loop & 31)) {
      ADC0MX = 0x0e; // P1.6
      ADC0 = 0x00;
      ADC0CN0_ADBUSY = true;
      os_wait1(RDY_EVENT);
      sample = ADC0;
      if (sample >= CO_ADC_LETHAL)
        co_level = CO_LEVEL_LETHAL;
      else if (sample >= CO_ADC_CRITICAL)
        co_level = CO_LEVEL_CRITICAL;
      else if (sample >= CO_ADC_WARNING)
        co_level = CO_LEVEL_WARNING;
      else
        co_level = CO_LEVEL_OK;
    }

		// Read fuel gauge state of charge
		if (!(loop & 63)) {
      // Get the state of charge
		  smbus_write_command(BQ27441_COMMAND_SOC);
		  os_wait1(RDY_EVENT);
		  if (!smbus_error) {
		      os_wait2(K_TMO, 1);
		      smbus_read16();
		      os_wait1(RDY_EVENT);
		      if (!smbus_error) {
		          sample = ((uint16_t)smbus_data1 << 8) | smbus_data0;
		          PCA0 = sample;
		      }
		  }

			if (smbus_error) {
				bat_charge = BAT_CHARGE_ERROR;
				PCA0 = 0xff00;
			}
			else if (sample < BAT_SOC_EMPTY)
				bat_charge = BAT_CHARGE_EMPTY;
			else if (sample < BAT_SOC_CRITICAL)
				bat_charge = BAT_CHARGE_CRITICAL;
			else if (sample < BAT_SOC_WARNING)
				bat_charge = BAT_CHARGE_WARNING;
			else
				bat_charge = BAT_CHARGE_OK;
		}
		// DEBUG
		bat_charge = BAT_CHARGE_OK;

		// Pause the task for 100 ms
		watchdog_mask &= ~WATCHDOG_MASK_SENSORS;
		os_wait2(K_IVL, 100);
		loop++;
	}
}
