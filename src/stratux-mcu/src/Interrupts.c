//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>
#include <rtx51tny.h>
#include "DeviceConfig.h"

//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
//-----------------------------------------------------------------------------

SI_INTERRUPT(ADC0EOC_ISR, ADC0EOC_IRQn) {
	ADC0CN0_ADINT = false;
	isr_set_ready(TASK_ID_SENSORS);
}

//-----------------------------------------------------------------------------
// TIMER2_ISR
//-----------------------------------------------------------------------------
//
// TIMER2 ISR Content goes here. Remember to clear flag bits:
// TMR2CN0::TF2H (Timer # High Byte Overflow Flag)
// TMR2CN0::TF2L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------

SI_INTERRUPT(TIMER2_ISR, TIMER2_IRQn) {
	static bit buzz = false;

	buzz = !buzz;
	O_BUZZER = buzz;
	TMR2CN0_TF2H = false;
}

//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
// TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------

uint8_t data interval = 0; // 32 = 1 second
uint8_t data main_countdown = 0; // 2 = 1 second count down
uint8_t data status_countup = 0xff; // 32 = second

SI_INTERRUPT(TIMER3_ISR, TIMER3_IRQn) {
	TMR3CN0 &= ~TMR3CN0_TF3H__SET;
	interval++;
	if (main_countdown && !(interval & 31)) main_countdown--;
	if (status_countup != 0xff) status_countup++;
	watchdog_mask &= ~WATCHDOG_MASK_TIMER;
}

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN0::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------

bit smbus_read = false;
bit smbus_error = false;
bit smbus_busy = false;
uint8_t data smbus_cmd;
uint8_t data smbus_data0;
uint8_t data smbus_data1;

SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn) {
  bit fail = false;
  static bit addr_sent = false;
  static bit data_rcv = false;

  if (!SMB0CN0_ARBLOST) {
      // Normal operation
      switch (SMB0CN0 & 0xf0) {
          // Master Transmitter/Receiver: START condition transmitted.
          case SMB0CN0_MTSTA:
            SMB0DAT = smbus_read ? BQ72441_I2C_ADDRESS | 0x01 : BQ72441_I2C_ADDRESS & 0xfe;
            SMB0CN0_STA = false;
            addr_sent = true;
            data_rcv = false;
            break;

          // Master Transmitter: Data byte transmitted
          case SMB0CN0_MTDB:
            if (SMB0CN0_ACK) {
                if (addr_sent) {
                    addr_sent = false;
                    if (!smbus_read) {
                        SMB0DAT = smbus_cmd;
                    }
                    else {}
                }
                else {
                    SMB0CN0_STO = true;
                    // Signal the task that we are done
                    if (smbus_busy) isr_set_ready(TASK_ID_SENSORS);
                    smbus_busy = false;
                }
            }
            else {
                smbus_error = true;
                SMB0CN0_STO = true;
            }
            break;

          // Master Receiver: byte received
          case SMB0CN0_MRDB:
            if (!data_rcv) {
                smbus_data0 = SMB0DAT;
                data_rcv = true;
                SMB0CN0_ACK = true;
            }
            else {
                smbus_data1 = SMB0DAT;
                SMB0CN0_ACK = false;
                SMB0CN0_STO = true;

                // Signal the task that we are done
                if (smbus_busy) isr_set_ready(TASK_ID_SENSORS);
                smbus_busy = false;
            }
            break;

          default:
            fail = true;
            break;
      }
  }
  else {
      fail = true;
  }

  // Reset state on failure
  if (fail) {
    SMB0CF &= ~0x80;
    SMB0CF |= 0x80;
    SMB0CN0_STA = false;
    SMB0CN0_STO = false;
    SMB0CN0_ACK = false;
    smbus_error = true;

    // Signal the task that we are done
    if (smbus_busy) isr_set_ready(TASK_ID_SENSORS);
    smbus_busy = false;
  }

  // Clear interrupt flag
  SMB0CN0_SI = false;
}
